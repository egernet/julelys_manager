<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Preview: {{SEQUENCE_NAME}}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #111;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden;
        }
        h1 { margin-bottom: 10px; font-size: 1.5em; }
        .info { color: #888; margin-bottom: 20px; font-size: 0.9em; }
        #canvas2d {
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255,255,255,0.1);
        }
        #container3d {
            width: 100%;
            height: 70vh;
            display: none;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            background: #333;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover { background: #444; }
        button.active { background: #0a0; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        input[type="range"] { width: 80px; }
        .status {
            color: #888;
            font-size: 0.85em;
            min-width: 80px;
            text-align: center;
        }
        .status.running { color: #0f0; }
        .view-toggle { margin-left: 10px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <h1>{{SEQUENCE_NAME}}</h1>
    <div class="info">{{MATRIX_WIDTH}} x {{MATRIX_HEIGHT}} LED matrix <span id="viewInfo"></span></div>
    <canvas id="canvas2d"></canvas>
    <div id="container3d"></div>
    <div class="controls">
        <button id="startStop" class="active">‚èπ Stop</button>
        <button id="restart">üîÑ Restart</button>
        <button id="toggleView" class="view-toggle">3D</button>
        <div class="speed-control">
            <span>Speed:</span>
            <input type="range" id="speed" min="10" max="200" value="100">
            <span id="speedLabel">1x</span>
        </div>
        <div class="speed-control">
            <span>Strenge:</span>
            <input type="range" id="strings" min="1" max="{{MATRIX_WIDTH}}" value="{{MATRIX_WIDTH}}">
            <span id="stringsLabel">{{MATRIX_WIDTH}}</span>
        </div>
        <div class="speed-control" id="autoRotateControl" style="display: none;">
            <span>Auto-roter:</span>
            <input type="checkbox" id="autoRotate" checked>
        </div>
        <div class="status" id="status">Running...</div>
    </div>

    <script>
    // LED Matrix simulation
    const MAX_WIDTH = {{MATRIX_WIDTH}};
    const HEIGHT = {{MATRIX_HEIGHT}};
    const SCALE = 12;
    const LED_RADIUS = 5;

    let visibleStrings = MAX_WIDTH;
    let is3DMode = false;

    // ============ 2D Setup ============
    const canvas2d = document.getElementById('canvas2d');
    const ctx = canvas2d.getContext('2d');

    const treeHeight2d = HEIGHT * SCALE;
    const fanRadius = HEIGHT * SCALE * 0.6;
    const fanAngle = Math.PI * 0.4;
    const centerX2d = fanRadius + SCALE;
    const treeBaseWidth = centerX2d * 2;

    canvas2d.width = treeBaseWidth;
    canvas2d.height = treeHeight2d;

    function computeLedPositions2D(numStrings) {
        const positions = [];
        for (let row = 0; row < HEIGHT; row++) {
            positions[row] = [];
            const progress = row / (HEIGHT - 1);
            const minRowWidth = numStrings * SCALE;
            const maxRowWidth = 2 * fanRadius * Math.sin(fanAngle / 2);
            const rowWidth = maxRowWidth - progress * (maxRowWidth - minRowWidth);

            for (let col = 0; col < numStrings; col++) {
                const spacing = rowWidth / numStrings;
                const xOffset = (col - (numStrings - 1) / 2) * spacing;
                positions[row][col] = {
                    x: centerX2d + xOffset,
                    y: treeHeight2d - (row * SCALE + SCALE / 2)
                };
            }
        }
        return positions;
    }

    let ledPositions2D = computeLedPositions2D(visibleStrings);

    // ============ 3D Setup ============
    const container3d = document.getElementById('container3d');
    let scene, camera, renderer, controls3d;
    let ledMeshes = [];
    let glowTexture;

    const baseRadius3d = 15;
    const topRadius3d = 2;

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        camera = new THREE.PerspectiveCamera(60, container3d.clientWidth / container3d.clientHeight, 0.1, 1000);
        camera.position.set(0, 30, 80);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container3d.clientWidth, container3d.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container3d.appendChild(renderer.domElement);

        controls3d = new THREE.OrbitControls(camera, renderer.domElement);
        controls3d.enableDamping = true;
        controls3d.dampingFactor = 0.05;
        controls3d.autoRotate = true;
        controls3d.autoRotateSpeed = 1.0;
        controls3d.target.set(0, 25, 0);

        // Create glow texture
        const glowCanvas = document.createElement('canvas');
        glowCanvas.width = 64;
        glowCanvas.height = 64;
        const glowCtx = glowCanvas.getContext('2d');
        const gradient = glowCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.3, 'rgba(255,255,255,0.5)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        glowCtx.fillStyle = gradient;
        glowCtx.fillRect(0, 0, 64, 64);
        glowTexture = new THREE.CanvasTexture(glowCanvas);

        // Add flagpole
        const poleGeometry = new THREE.CylinderGeometry(0.5, 0.5, HEIGHT + 10, 16);
        const poleMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
        pole.position.y = HEIGHT / 2 - 5;
        scene.add(pole);

        // Add ground
        const groundGeometry = new THREE.CircleGeometry(25, 32);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        scene.add(ground);

        createLedMeshes(visibleStrings);
        animate3D();
    }

    const ledGeometry = new THREE.SphereGeometry(0.4, 16, 16);

    function createLedMeshes(numStrings) {
        // Remove old meshes
        ledMeshes.forEach(row => {
            row.forEach(led => {
                scene.remove(led.sphere);
                scene.remove(led.glow);
            });
        });
        ledMeshes.length = 0;

        for (let row = 0; row < HEIGHT; row++) {
            ledMeshes[row] = [];
            const progress = row / (HEIGHT - 1);
            const radius = baseRadius3d * (1 - progress) + topRadius3d * progress;
            const y = row;

            for (let col = 0; col < numStrings; col++) {
                const angle = (col / numStrings) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                const material = new THREE.MeshBasicMaterial({ color: 0x222222 });
                const sphere = new THREE.Mesh(ledGeometry, material);
                sphere.position.set(x, y, z);
                scene.add(sphere);

                const glowMaterial = new THREE.SpriteMaterial({
                    map: glowTexture,
                    color: 0x000000,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                const glow = new THREE.Sprite(glowMaterial);
                glow.scale.set(3, 3, 1);
                glow.position.set(x, y, z);
                glow.visible = false;
                scene.add(glow);

                ledMeshes[row][col] = { sphere, glow, material, glowMaterial };
            }
        }
    }

    function animate3D() {
        requestAnimationFrame(animate3D);
        if (is3DMode && controls3d) {
            controls3d.update();
            renderer.render(scene, camera);
        }
    }

    // ============ Shared State ============
    let pixels = [];
    for (let row = 0; row < HEIGHT; row++) {
        pixels[row] = [];
        for (let col = 0; col < MAX_WIDTH; col++) {
            pixels[row][col] = [0, 0, 0, 0];
        }
    }

    let speedMultiplier = 1.0;
    let shouldStop = false;
    let isRunning = false;

    const matrix = {
        get width() { return visibleStrings; },
        height: HEIGHT
    };

    function setPixelColor(r, g, b, w, x, y) {
        if (x >= 0 && x < HEIGHT && y >= 0 && y < MAX_WIDTH) {
            pixels[x][y] = [r, g, b, w];
        }
    }

    function updatePixels() {
        if (is3DMode) {
            updatePixels3D();
        } else {
            updatePixels2D();
        }
    }

    function updatePixels2D() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas2d.width, canvas2d.height);

        for (let row = 0; row < HEIGHT; row++) {
            for (let col = 0; col < visibleStrings; col++) {
                const [r, g, b, w] = pixels[row][col];
                const rr = Math.min(255, r + w / 2);
                const gg = Math.min(255, g + w / 2);
                const bb = Math.min(255, b + w / 2);

                const pos = ledPositions2D[row][col];
                const x = pos.x;
                const y = pos.y;

                if (rr > 20 || gg > 20 || bb > 20) {
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, LED_RADIUS * 1.5);
                    gradient.addColorStop(0, `rgba(${rr},${gg},${bb},0.8)`);
                    gradient.addColorStop(1, `rgba(${rr},${gg},${bb},0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, LED_RADIUS * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                const isOff = rr < 5 && gg < 5 && bb < 5;
                ctx.fillStyle = isOff ? '#222' : `rgb(${rr},${gg},${bb})`;
                ctx.beginPath();
                ctx.arc(x, y, LED_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function updatePixels3D() {
        for (let row = 0; row < HEIGHT; row++) {
            for (let col = 0; col < visibleStrings; col++) {
                const [r, g, b, w] = pixels[row][col];
                const rr = Math.min(255, r + w / 2);
                const gg = Math.min(255, g + w / 2);
                const bb = Math.min(255, b + w / 2);

                const led = ledMeshes[row] && ledMeshes[row][col];
                if (!led) continue;

                const isOff = rr < 5 && gg < 5 && bb < 5;
                const color = isOff ? 0x222222 : (rr << 16) | (gg << 8) | bb;
                led.material.color.setHex(color);

                if (!isOff) {
                    led.glow.visible = true;
                    led.glowMaterial.color.setHex(color);
                    led.glowMaterial.opacity = 0.6;
                } else {
                    led.glow.visible = false;
                }
            }
        }
    }

    function delay(ms) {
        if (shouldStop) throw new Error('stopped');
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => resolve(), ms / speedMultiplier);
            const check = setInterval(() => {
                if (shouldStop) {
                    clearTimeout(timeout);
                    clearInterval(check);
                    reject(new Error('stopped'));
                }
            }, 50);
        });
    }

    function clearPixels() {
        for (let row = 0; row < HEIGHT; row++) {
            for (let col = 0; col < MAX_WIDTH; col++) {
                pixels[row][col] = [0, 0, 0, 0];
            }
        }
        updatePixels();
    }

    // The sequence code
    async function runSequence() {
        {{JS_CODE}}
    }

    async function start() {
        shouldStop = false;
        isRunning = true;
        document.getElementById('status').textContent = 'Running...';
        document.getElementById('status').className = 'status running';
        document.getElementById('startStop').textContent = '‚èπ Stop';
        document.getElementById('startStop').classList.add('active');

        try {
            await runSequence();
            document.getElementById('status').textContent = 'Finished';
        } catch (e) {
            if (e.message !== 'stopped') {
                document.getElementById('status').textContent = 'Error: ' + e.message;
                console.error(e);
            } else {
                document.getElementById('status').textContent = 'Stopped';
            }
        }

        isRunning = false;
        document.getElementById('status').className = 'status';
        document.getElementById('startStop').textContent = '‚ñ∂ Start';
        document.getElementById('startStop').classList.remove('active');
    }

    function stop() {
        shouldStop = true;
    }

    function toggleView() {
        is3DMode = !is3DMode;
        document.getElementById('toggleView').textContent = is3DMode ? '2D' : '3D';
        document.getElementById('autoRotateControl').style.display = is3DMode ? 'flex' : 'none';
        document.getElementById('viewInfo').textContent = is3DMode ? '- Tr√¶k for at rotere' : '';

        if (is3DMode) {
            canvas2d.style.display = 'none';
            container3d.style.display = 'block';
            if (!scene) {
                init3D();
            } else {
                createLedMeshes(visibleStrings);
            }
            // Resize renderer
            renderer.setSize(container3d.clientWidth, container3d.clientHeight);
            camera.aspect = container3d.clientWidth / container3d.clientHeight;
            camera.updateProjectionMatrix();
        } else {
            canvas2d.style.display = 'block';
            container3d.style.display = 'none';
        }
        updatePixels();
    }

    // Controls
    document.getElementById('startStop').addEventListener('click', function() {
        if (isRunning) {
            stop();
        } else {
            start();
        }
    });

    document.getElementById('restart').addEventListener('click', function() {
        stop();
        clearPixels();
        setTimeout(() => start(), 100);
    });

    document.getElementById('toggleView').addEventListener('click', toggleView);

    document.getElementById('speed').addEventListener('input', function() {
        speedMultiplier = this.value / 100;
        document.getElementById('speedLabel').textContent = speedMultiplier.toFixed(1) + 'x';
    });

    document.getElementById('strings').addEventListener('input', function() {
        visibleStrings = parseInt(this.value);
        document.getElementById('stringsLabel').textContent = visibleStrings;
        ledPositions2D = computeLedPositions2D(visibleStrings);
        if (is3DMode && scene) {
            createLedMeshes(visibleStrings);
        }
        clearPixels();
    });

    document.getElementById('autoRotate').addEventListener('change', function() {
        if (controls3d) {
            controls3d.autoRotate = this.checked;
        }
    });

    window.addEventListener('resize', () => {
        if (is3DMode && renderer) {
            renderer.setSize(container3d.clientWidth, container3d.clientHeight);
            camera.aspect = container3d.clientWidth / container3d.clientHeight;
            camera.updateProjectionMatrix();
        }
    });

    // Initial render and start
    updatePixels();
    start();
    </script>
</body>
</html>
